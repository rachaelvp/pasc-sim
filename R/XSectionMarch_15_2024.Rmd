---
title: "Cross-sectional Data simulation"
subtitle: "Simple Simulation using Empirical for W"
date: "`r Sys.Date()`"
output: pdf_document
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


# Load packages

```{r}
library(data.table)
library(dplyr)
library(glmnet)
library(R6)
library(sl3)
library(tmle3)
library(hal9001)

rm(list = ls())
source("uhal.R")
```


# Generate Original Data 


```{r}
generate_data_simple <- function(N,Xranges=c(-1,1,-1,1),betaA=c(0,0.1,-0.4),
                                 betaY0=c(0,1,2,-1),betaC=c(1,7/5,5,3),sdy=1){
  # A simple data generating process
  X1 <- runif(N,Xranges[1],Xranges[2])
  X2 <- runif(N,Xranges[3],Xranges[4])
  pi0 <- plogis(betaA[1]+betaA[2]*X1*X2+betaA[3]*X1)
  A <- rbinom(N,1,prob=pi0)
  muY0 <- betaY0[1]+betaY0[2]*X1*X2 + betaY0[3]*X2^2 +betaY0[4]*X1
  CATE <- betaC[1]*X1^2*(X1+betaC[2]) + (betaC[3]*X2/betaC[4])^2
  muY = muY0+A*CATE
  Y <- rnorm(N,sd=sdy,mean= muY)
  return(tibble(X1=X1,X2=X2,A=A,Y=Y))
}

# true ATE = 1.39
set.seed(123)
df <- generate_data_simple(N=500)
```

# Get True Values

```{r}
True_values <- function(N=100000,Xranges=c(-1,1,-1,1),betaA=c(0,0.1,-0.4),
                                 betaY0=c(0,1,2,-1),betaC=c(1,7/5,5,3),sdy=1){
  # A simple data generating process
  X1 <- runif(N,Xranges[1],Xranges[2])
  X2 <- runif(N,Xranges[3],Xranges[4])
  pi0 <- plogis(betaA[1]+betaA[2]*X1*X2+betaA[3]*X1)
  P0A = mean(pi0)
  A <- rbinom(N,1,prob=pi0)
  muY0 <- betaY0[1]+betaY0[2]*X1*X2 + betaY0[3]*X2^2 +betaY0[4]*X1
  CATE <- betaC[1]*X1^2*(X1+betaC[2]) + (betaC[3]*X2/betaC[4])^2
  true.ATE <- mean(CATE)
  muY = muY0+A*CATE
  Y <- rnorm(N,sd=sdy,mean= muY)
  P0Y <- mean(Y)
  coef.work <- coef(lm(Y~A+X1+X2))
  return(list(P0A=P0A,P0Y=P0Y,true.ATE,coef.work))
}
psiP0 <- True_values()
```


# Generate Synthetic Data with undersmoothed HAL
We also should try to use CV-HAL as we are trying to preserve not just functionals
but the entire distribution

```{r}
node_list <- list(
  W = setdiff(names(df), c("A", "Y")),
  A = "A",
  Y = "Y"
)

lrnr_uhal <- Lrnr_uhal9001$new()

res_Qg <- fit_uhal_Qg(df = df, 
                      y_type = "continuous", 
                      covars = node_list$W)

set.seed(123)
df_syn <- generate_uhal_data(n = nrow(df), 
                             df = df, 
                             y_type = "continuous", 
                             g_fit = res_Qg$g_fit, 
                             Q_fit = res_Qg$Q_fit)

```

# Get the estimates of simple parameters

```{r}
aveAn <- mean(df$A)
aveAs <- mean(df_syn$A)
aveYn <- mean(df$Y)
aveYs <- mean(df_syn$Y)
lmn <- lm(Y~A+X1+X2,data=df)
lms <- lm(Y~A+X1+X2,data=df_syn)
coeffn <- coef(lmn)
coeffs <- coef(lms)
seAn <- summary(lmn)$coefficients[2,2]
seAs <- summary(lms)$coefficients[2,2]
psiP0

```




# TMLE ATE on original data and synthetic data

```{r}
ate_spec <- tmle_ATE(
  treatment_level = 1,
  control_level = 0
)

# choose base learners
lrnr_mean <- make_learner(Lrnr_mean)
lrnr_xgb <- make_learner(Lrnr_xgboost)
lrnr_earth <- make_learner(Lrnr_earth)
lrnr_glm <- make_learner(Lrnr_glm)

# define metalearners appropriate to data types
ls_metalearner <- make_learner(Lrnr_nnls)
lb_metalearner <- make_learner(Lrnr_solnp,
                               learner_function = metalearner_logistic_binomial,
                               loss_function = loss_loglik_binomial)
sl_Y <- Lrnr_sl$new(
  learners = list(lrnr_mean, lrnr_glm, lrnr_earth),
  metalearner = ls_metalearner
)
sl_A <- Lrnr_sl$new(
  learners = list(lrnr_mean, lrnr_glm, lrnr_earth),
  metalearner = lb_metalearner
)
learner_list <- list(A = sl_A, Y = sl_Y)
```


# estimate ATE with original data
```{r}

tmle_fit_org <- tmle3(ate_spec, df, node_list, learner_list)
print(tmle_fit_org)
```


# estimate ATE with synthetic data
```{r}
tmle_fit_syn <- tmle3(ate_spec, df_syn, node_list, learner_list)
print(tmle_fit_syn)

```

